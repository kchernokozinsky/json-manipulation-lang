use std::str::FromStr;
use lexer::token::{Token, errors::LexingError};
use crate::ast::{ExpressionKind, Expression, Statement, StatementKind, Identifier, Jml};

grammar<'source>(source: &'source str);


pub Jml: Jml<'source> = {
    <header: Statement*> HEADER <body:Expression> => Jml{
        header: header, 
        body
    }  
};

pub Statement: Statement<'source> = {
    <l:@L> <identifier:Identifier> "=" <expression:Expression> <r:@L> => Statement
        {
            l,
            r,
            node: StatementKind::Bind{identifier, expression},
        },
};

pub Expression: Expression<'source> = {
    ExpressionPrecedence1,
    };

ExpressionPrecedence1: Expression<'source> = {
    Object,
    List,
    Literal,
    Variable,
    "(" <Expression> ")",

};

Literal: Expression<'source> = {
    Bool,
    String,
    Null,
    Float,
    Int,
};

Identifier: Identifier<'source> = {
   <l:@L> <s: IDENTIFIER> <r:@L> => Identifier {
        l,
        r,
        node: s
    }
};

Variable: Expression<'source> = {
   <l:@L> <s: IDENTIFIER> <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::Variable(s)
    }
};

String: Expression<'source> = {
   <l:@L> <s: STRING_LITERAL> <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::String(s)
    }
};

Null: Expression<'source> = {
   <l:@L> NULL <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::Null
    }
};

Bool: Expression<'source> = {
    <l:@L> <b: BOOL_LITERAL> <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::Bool(b)
    }
};

Float: Expression<'source> = {
    <l:@L> <f: FLOAT_LITERAL> <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::Float(f)
    }
};

Object: Expression<'source> = {
    <l:@L> "{" <pairs:Comma<(<STRING_LITERAL> ":" <Expression>)>> "}" <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::Object(pairs.into_iter()
                                            .collect()),
    }
};

List: Expression<'source> = {
    <l:@L> "[" <elems:Comma<Expression>> "]" <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::List(elems),
    }
};

Int: Expression<'source> = {
    <l:@L> <i: INT_LITERAL> <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::Int(i)
    }
};

#[inline]
Comma<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T?> => match e { 
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

extern {
    type Location = usize;
    type Error = LexingError;

    enum Token<'source> {
        // Keywords
        HEADER        => Token::Header,
        LET           => Token::Let,
        NULL          => Token::Null,
        FILTER        => Token::Filter,
        MAP           => Token::Map,
        MAPOBJ        => Token::MapObject,
        FILTEROBJ     => Token::FilterObject,
        FN            => Token::Fn,
        IF            => Token::If,
        ELSE          => Token::Else,
        READ          => Token::Read,
        WRITE         => Token::Write,
        LOG           => Token::Log,

        // Types
        STRING_TYPE   => Token::StringType,
        FLOAT_TYPE    => Token::FloatType,
        BOOL_TYPE     => Token::BoolType,
        INT_TYPE      => Token::IntType,
        ARRAY_TYPE    => Token::ArrayType,
        OBJECT_TYPE   => Token::ObjectType,
        NULLTYPE_TYPE => Token::NullType,

        // Literals and Identifiers
        STRING_LITERAL => Token::StringLiteral(<&'source str>),
        IDENTIFIER     => Token::Identifier(<&'source str>),
        INT_LITERAL    => Token::IntLiteral(<i64>),
        FLOAT_LITERAL => Token::FloatLiteral(<f64>),
        BOOL_LITERAL    => Token::BoolLiteral(<bool>),

        // Operators
        "+"             => Token::Plus,
        "-"             => Token::Minus,
        "*"             => Token::Star,
        "/"             => Token::Slash,
        "=="            => Token::Equal,
        "!="            => Token::NotEqual,
        "<"             => Token::LessThan,
        ">"             => Token::GreaterThan,
        "<="            => Token::LessEqual,
        ">="            => Token::GreaterEqual,
        "&&"            => Token::And,
        "||"            => Token::Or,
        "!"             => Token::Not,
        "="             => Token::Assign,

        // Symbols
        "."             => Token::Dot,
        ","             => Token::Comma,
        ":"             => Token::Colon,
        ";"             => Token::Semicolon,
        "("             => Token::LParen,
        ")"             => Token::RParen,
        "["             => Token::LBracket,
        "]"             => Token::RBracket,
        "{"             => Token::LBrace,
        "}"             => Token::RBrace,
        "=>"         => Token::Arrow,

    }
}