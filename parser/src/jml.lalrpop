use std::str::FromStr;
use lexer::token::{Token, errors::LexingError};
use crate::ast::{ExpressionKind, Expression};
grammar<'source>(source: &'source str);


pub Literal: Expression<'source> = {
    Bool,
    String,
};

String: Expression<'source> = {
   <l:@L> <s: STRING_LITERAL> <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::String(s)
    }
};

Bool: Expression<'source> = {
    <l:@L> <b: BOOL_LITERAL> <r:@L> => Expression {
        l,
        r,
        node: ExpressionKind::Bool(b)
    }
};

extern {
    type Location = usize;
    type Error = LexingError;

    enum Token<'source> {
        // Keywords
        LET           => Token::Let,
        NULL          => Token::Null,
        FILTER        => Token::Filter,
        MAP           => Token::Map,
        MAPOBJ        => Token::MapObject,
        FILTEROBJ     => Token::FilterObject,
        FN            => Token::Fn,
        IF            => Token::If,
        ELSE          => Token::Else,
        READ          => Token::Read,
        WRITE         => Token::Write,
        LOG           => Token::Log,

        // Types
        STRING_TYPE   => Token::StringType,
        FLOAT_TYPE    => Token::FloatType,
        BOOL_TYPE     => Token::BoolType,
        INT_TYPE      => Token::IntType,
        ARRAY_TYPE    => Token::ArrayType,
        OBJECT_TYPE   => Token::ObjectType,
        NULLTYPE_TYPE => Token::NullType,

        // Literals and Identifiers
        STRING_LITERAL => Token::StringLiteral(<&'source str>),
        IDENTIFIER     => Token::Identifier(<&'source str>),
        INT_LITERAL    => Token::IntLiteral(<i64>),
        FLOAT_LITERAL => Token::FloatLiteral(<f64>),

        // Boolean Literals
        BOOL_LITERAL    => Token::BoolLiteral(<bool>),
        // Operators
        "+"             => Token::Plus,
        "-"             => Token::Minus,
        "*"             => Token::Star,
        "/"             => Token::Slash,
        "=="            => Token::Equal,
        "!="            => Token::NotEqual,
        "<"             => Token::LessThan,
        ">"             => Token::GreaterThan,
        "<="            => Token::LessEqual,
        ">="            => Token::GreaterEqual,
        "&&"            => Token::And,
        "||"            => Token::Or,
        "!"             => Token::Not,
        "="             => Token::Assign,

        // Symbols
        "."             => Token::Dot,
        ","             => Token::Comma,
        ":"             => Token::Colon,
        ";"             => Token::Semicolon,
        "("             => Token::LParen,
        ")"             => Token::RParen,
        "["             => Token::LBracket,
        "]"             => Token::RBracket,
        "{"             => Token::LBrace,
        "}"             => Token::RBrace,
        "=>"         => Token::Arrow,

    }
}